# 案例5：高级树与索引结构（AVL / Trie / B 树 / B+ 树）

> 本案例偏“原理理解 + 口述能力”，代码给出接口/伪代码为主，方便你在需要时自己实现或画图讲解。

## 1. AVL 树（自平衡二叉搜索树）

### 1.1 一句话讲明白
AVL 是一种“永远尽量长得不歪”的二叉搜索树，通过旋转保持平衡，让查找始终接近 O(log n)。

### 1.2 关键知识点
- 仍是 BST：左子树 < 根 < 右子树
- **平衡因子（balance factor）**：某个节点的 `height(left) - height(right)` ∈ {-1, 0, 1}
- 插入/删除后如果某个节点失衡，通过 **LL / RR / LR / RL 四种旋转** 恢复平衡

### 1.3 Java 接口示意（不展开实现）

```java
interface AvlTree {
    void insert(int val);
    void remove(int val);
    boolean contains(int val);
}
```

你需要能画出 **简单插入触发旋转** 的例子，例如：
- 插入顺序：`10, 8, 6` → 触发 LL 旋转
- 插入顺序：`10, 6, 8` → 触发 LR 旋转

### 1.4 费曼式讲解要点
- 普通 BST 可能因为插入顺序不好而退化成链表（查找 O(n)）
- AVL 在插入/删除后检查“有没有太偏”，如果太偏就通过旋转让树重新变矮
- 所以 AVL 始终保证高度为 O(log n)，查找/插入/删除最坏都是 O(log n)

---

## 2. Trie（前缀树 / 字典树）

### 2.1 一句话讲明白
Trie 是“按字符一层层往下走”的树，特别适合做前缀匹配与自动补全。

### 2.2 关键知识点
- 每条从根到某个节点的路径代表一个前缀
- 每个节点通常包含：
  - `children[字符]` 指向下一层
  - `isWord` 标记这里是否是一个完整单词的结尾
- 插入/查找复杂度与字符串长度 m 成正比：O(m)

### 2.3 Java 接口示意

```java
public class Trie {
    private static class Node {
        Node[] children = new Node[26]; // 仅考虑小写 a-z 的简化版
        boolean isWord;
    }

    private final Node root = new Node();

    // 插入单词
    public void insert(String word) { /* 按字符逐层创建节点 */ }

    // 判断是否存在完整单词
    public boolean search(String word) { /* 沿路径走到结尾 + isWord=true */ }

    // 判断是否存在前缀
    public boolean startsWith(String prefix) { /* 只要能走到前缀结尾即可 */ }
}
```

### 2.4 小案例（验证数据）
- 单词集：`["dog", "door", "cat"]`
  - `search("dog")` → true
  - `search("do")` → false
  - `startsWith("do")` → true

---

## 3. B 树（B-Tree）

### 3.1 一句话讲明白
B 树是一种“每个节点可以有很多 key 和很多孩子”的平衡搜索树，专门为**磁盘/SSD 块存储**设计，用来减少磁盘 IO 次数。

### 3.2 关键知识点（直觉版）
- 多路搜索树：一个节点里不止 1 个 key，而是很多 key（有序）和很多子指针
- 树是严格平衡的：所有叶子在同一层
- 节点太满时会**分裂**成两个，并把中间 key 提升到父节点
- 查找/插入/删除复杂度都是 O(logₘ n)，m 是每个节点最大 key 数

### 3.3 用“图”来记，而不是死记定义
可以在纸上画一个简单的 B 树（阶数 m=3 或 4），比如：
- 根节点有 2 个 key：`[10 | 20]`
- 三个子节点范围分别是：(-∞,10)、(10,20)、(20,+∞)

你要能解释：
- 查找 15 时，先在根节点里看哪个区间，再下到中间子节点
- 相比二叉树，这样可以用更少的高度覆盖更多 key

---

## 4. B+ 树（B+Tree）

### 4.1 一句话讲明白
B+ 树是在 B 树基础上的改造版：**所有数据都放在叶子节点，叶子之间用链表串起来**，非常适合做数据库索引和范围查询。

### 4.2 关键知识点
- 内部节点（非叶子）只存 key，不存实际数据（只负责“导航”）
- 所有数据行都在叶子节点里
- 叶子节点之间通过指针连成有序链表

**好处**：
- 点查：仍然是 O(log n)
- 范围查（比如 `WHERE age BETWEEN 20 AND 30`）：
  - 先定位到第一个命中的叶子
  - 沿着叶子链表往后扫，直到超过上界即可

### 4.3 与数据库的关系
- MySQL InnoDB 的聚簇索引（二级索引）本质就是 B+ 树
- 你要能口头画出一棵简化的 B+ 树，解释：
  - 内部节点如何引导查找
  - 叶子节点如何按 key 排序并串成链表

---

## 5. 在你的知识图谱里的位置

结合前面的 BST 案例，可以这样串起来：

1. **BST**：查找快，但容易退化成链表  
2. **AVL/红黑树**：在 BST 上加“自平衡”机制，保证高度 O(log n)  
3. **Trie**：当 key 变成“字符串/前缀”时，比基于比较的树更合适  
4. **B 树/B+ 树**：当数据量大到要落到磁盘时，用更矮的多路树减少 IO 次数

如果你能用自己的话把这 4 种树讲给别人听（配合画图），再能大致说出它们各自“适合解决什么问题”，基本就达到了面试与实战的要求。

