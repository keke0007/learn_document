# Java 数据结构与算法学习指南（费曼学习法）

> 目标：把常见数据结构与算法学到“能用自己的话讲清楚 + 能写出 Java 代码 + 能用小数据对照结果”的程度。

本目录自带：
- **验证数据**：`data_structure/data/`
  - `numbers_small.txt`、`numbers_unsorted.txt`、`linked_list_values.txt`、`tree_nodes.txt`
- **案例**：`data_structure/cases/`
  - `cases/README.md`（索引）
  - 4 个可运行的 Java 案例文档
- **运行说明**：`data_structure/scripts/run_examples.md`

---

## 0. 费曼学习法在数据结构与算法上的用法

对每个知识点，都按这 5 步：
- **一句话讲明白**：讲给没写过代码的人也能听懂
- **关键术语补齐**：时间复杂度 / 空间复杂度 / 典型操作
- **能写出的最小 Java 示例**：10–30 行代码就够
- **能手算的小数据**：文件里的 5~10 个数字就能验证
- **能解释的坑**：边界条件、最坏情况、时间复杂度

---

## 1. 学习知识点清单（Java 视角）

### 1.1 数组（Array）
- **一句话**：一排连续的格子，按下标 O(1) 随机访问，但中间插入/删除很贵。
- **典型操作**：访问、更新、查找、插入、删除
- **你必须知道**：
  - 连续内存 → 随机访问 O(1)
  - 顺序查找 vs 二分查找（案例1）

### 1.2 链表（LinkedList）
- **一句话**：一串节点，每个节点指向下一个，插入/删除便宜，随机访问昂贵。
- **典型操作**：插入、删除、反转、合并
- **你必须知道**：
  - 单向 vs 双向链表
  - 头插法 / 尾插法
  - 反转链表（案例2）

### 1.3 栈（Stack）与队列（Queue）
- **栈一句话**：后进先出，就像一摞盘子（案例2 的括号匹配）。
- **队列一句话**：先进先出，就像排队买票。
- **典型应用**：
  - 栈：括号匹配、表达式求值、DFS 等
  - 队列：BFS、任务队列、消息队列

### 1.4 树与二叉搜索树（BST）
- **树一句话**：像家谱，一层层往下分。
- **BST 一句话**：左子树都比根小，右子树都比根大（案例3）。
- **你必须知道**：
  - 前序 / 中序 / 后序遍历含义
  - 对 BST 进行中序遍历会得到有序序列

### 1.5 排序算法（Sorting）
- **一句话**：把一堆数按大小排好顺序。
- **你必须知道**：
  - 冒泡 / 插入 / 选择排序：O(n²)，适合理解
  - 快排：平均 O(n log n)，实战常见（案例4）
  - 稳定 vs 不稳定、原地 vs 非原地

### 1.6 高级树与索引结构（AVL / Trie / B-Tree / B+Tree）
- **一句话**：
  - AVL：给 BST 加上“自平衡”，让树永远不太歪，查找始终 O(log n)
  - Trie：按字符一层层走的前缀树，适合前缀匹配/自动补全
  - B 树：节点很“胖”的多路搜索树，专为磁盘/SSD 设计，减少 IO
  - B+ 树：所有数据在叶子节点，叶子有序链表，范围查询更快
- **你必须知道**：
  - 它们各自“解决什么问题”，而不是死背定义
  - 为什么数据库索引用的是 B+ 树而不是普通 BST

### 1.7 时间复杂度与空间复杂度（Big-O）
- **一句话**：用“大概的数量级”描述算法跑慢不慢、占内存大不大。
- **你必须记住**：
  - 常见量级：O(1)、O(log n)、O(n)、O(n log n)、O(n²)
  - 不关心常数，只看 n 变大时的趋势

---

## 2. 案例与验证数据（建议顺序）

### 案例1：数组 + 时间复杂度 + 二分查找
- 文档：`cases/01_array_time_complexity_binary_search.md`
- 数据：`data/numbers_small.txt`
- 你要学会：
  - 写出标准的二分查找（返回索引 / -1）
  - 能解释为什么时间复杂度是 O(log n)

### 案例2：链表 + 栈/队列基本应用
- 文档：`cases/02_linked_list_stack_queue.md`
- 数据：`data/linked_list_values.txt`
- 你要学会：
  - 单链表的反转
  - 用栈解决括号匹配问题

### 案例3：二叉树遍历 + BST
- 文档：`cases/03_tree_traversal_bst.md`
- 数据：`data/tree_nodes.txt`
- 你要学会：
  - 前序 / 中序 / 后序遍历的顺序
  - BST 中序遍历有序的原因

### 案例4：常见排序算法对比
- 文档：`cases/04_sorting_algorithms_comparison.md`
- 数据：`data/numbers_unsorted.txt`
- 你要学会：
  - 冒泡 / 插入 / 选择 / 快排 的大致思路
  - 能说出每个算法的时间复杂度 & 是否稳定

### 案例5：高级树与索引结构
- 文档：`cases/05_advanced_trees_indexes.md`
- 你要学会：
  - 用自己的话解释 AVL / Trie / B 树 / B+ 树各自解决什么问题
  - 能画出简化示意图，说明查找/插入的大致过程

---

## 3. 用费曼法把知识点讲“透”的模板

你可以对每个算法按下面的模板复述一遍（对别人讲，或者大声讲给自己听）：

1. **这是什么？（一句话）**
   - “二分查找就是在有序数组里，每次对半缩小范围的查找方法。”
2. **解决什么问题？**
   - “当数组是有序时，想要比一个个找更快的查找方式。”
3. **核心步骤？**
   - “用 left 和 right 表示边界，计算 mid，比大小后缩小一半范围……”
4. **时间/空间复杂度？为什么？**
   - “每次砍一半，所以最多 log₂n 次……”
5. **常见坑？**
   - “left/right 边界错 / while 条件错 / mid 溢出 / 死循环……”

如果你能不看资料把这 5 点讲出来，说明这个算法暂时掌握了。

---

## 4. 最终总结：一页速查 Checklist

### 4.1 能用自己的话解释
- **数组**：连续内存，随机访问快，插入删除慢。
- **链表**：不连续，通过指针串起来，插入删除快，随机访问慢。
- **栈**：后进先出；**队列**：先进先出。
- **BST**：左 < 根 < 右；中序遍历有序。
- **排序**：O(n²) 的朴素算法 vs O(n log n) 的高效算法。
- **高级树**：AVL / Trie / B/B+ 树分别在“平衡查找 / 字符串前缀 / 磁盘索引”中的作用。

### 4.2 能写出的 Java 代码
- [ ] 写出一个标准的二分查找函数
- [ ] 写出一个单链表反转函数
- [ ] 写出前序 / 中序 / 后序遍历
- [ ] 写出至少一种排序（冒泡/插入/快排）

### 4.3 面试/实战常被问到的问题
- [ ] 为什么 HashMap 需要好的 hashCode（延伸到链表/红黑树）？
- [ ] 为什么快排平均很快，但最坏会很慢？如何优化？
- [ ] 数组、链表、栈、队列适合哪些场景？能不能举业务例子？

